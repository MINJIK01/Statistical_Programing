# check where does U locate
X = c()
for (i in 1:n){
for (j in 1:(length(size)+1)){
if (U[i] <= table[1]) {
X = c(X, 0)
break
}
else if (table[j] < U[i] && U[i] <= table[j+1]){
X = c(X, j+1)
break
}
else{
print(U[i])
}
}
}
table
print("Factor 0 : ", U[i])
print("Factor 0 : " + U[i])
print(paste("Factor 0 : ", U[i]))
# check where does U locate
X = c()
for (i in 1:n){
for (j in 1:(length(size)+1)){
if (U[i] <= table[1]) {
print(paste("Factor 0 : ", U[i]))
X = c(X, 0)
break
}
else if (table[j] < U[i] && U[i] <= table[j+1]){
X = c(X, j+1)
break
}
else{
print(U[i])
}
}
}
U
table
# check where does U locate
X = c()
for (i in 1:n){
for (j in 1:(length(size)+1)){
if (U[i] <= table[1]) {
print(i)
X = c(X, 0)
break
}
else if (table[j] < U[i] && U[i] <= table[j+1]){
print(i)
X = c(X, j)
break
}
else{
print(i)
}
}
}
length(X)
# check where does U locate
X = c()
for (i in 1:n){
for (j in 1:(length(size)+1)){
if (U[i] <= table[1]) {
print(i)
X = c(X, 0)
break
}
else if (table[j] < U[i] && U[i] <= table[j+1]){
print(i)
X = c(X, j)
break
}
else{
print(i)
break
}
}
}
length(X)
# check where does U locate
X = c()
for (i in 1:n){
print(paste("Run", i))
for (j in 1:(length(size)+1)){
if (U[i] <= table[1]) {
print(i)
X = c(X, 0)
break
}
else if (table[j] < U[i] && U[i] <= table[j+1]){
print(i)
X = c(X, j)
break
}
else{
print(i)
break
}
}
}
# check where does U locate
X = c()
for (i in 1:n){
for (j in 1:(length(size)+1)){
if (U[i] <= table[1]) {
print(i)
X = c(X, 0)
break
}
else if (table[j] < U[i] && U[i] <= table[j+1]){
print(i)
X = c(X, j)
break
}
else{
print(i)
break
}
}
}
# check where does U locate
X = c()
for (i in 1:n){
for (j in 1:(length(size)+1)){
if (U[i] <= table[1]) {
X = c(X, 0)
break
}
else if (table[j] < U[i] && U[i] <= table[j+1]){
X = c(X, j)
break
}
else{
print(i)
break
}
}
}
U
table
# check where does U locate
X = c()
for (i in 1:n){
for (j in 1:(length(size)+1)){
if (U[i] <= table[1]) {
X = c(X, 0)
break
}
else if (U[i] <= table[j+1]){
X = c(X, j)
break
}
}
}
length(X)
# check where does U locate
X = c()
for (i in 1:n){
for (j in 1:(length(size)+1)){
if (U[i] <= table[j]) {
X = c(X, j-1)
break
}
}
}
length(X)
X
# check where does U locate
X = c()
for (i in 1:n){
for (j in 1:(length(size)+1)){
print(i)
if (U[i] <= table[j]) {
X = c(X, j-1)
break
}
}
}
U
table
table[1]
table[2]
table[5]
# check where does U locate
X = c()
for (i in 1:n){
for (j in 1:(length(size)+1)){
print(j)
if (U[i] <= table[j]) {
X = c(X, j-1)
break
}
}
}
# check where does U locate
X = c()
for (i in 1:n){
for (j in 1:(length(size)+1)){
print(paste("U[i}: ",U[i]))
print(paste("j: ",j))
if (U[i] <= table[j]) {
X = c(X, j-1)
break
}
}
}
table[2]
istype(table[2])
astype(table[2])
typeof(table[2])
typeof(U[2])
# check where does U locate
X = c()
for (i in 1:n){
for (j in 1:(length(size)+1)){
print(paste("U[i}: ",U[i]))
print(paste("j: ",j))
if (U[i] <= table[j]) {
if (U[i] <= table[j]){
print("True")
}
X = c(X, j-1)
break
}
}
}
# check where does U locate
X = c()
for (i in 1:n){
for (j in 1:(length(size)+1)){
if (U[i] <= table[j]) {
if (U[i] <= table[j]){
print("True")
}
X = c(X, j-1)
break
}
}
}
length(size)+1
n = 100
size = 5
p = 0.2
U=runif(n) # generate random numbers following uniform distribution
sum = 0
table = c()
for (t in 0:size){
sum = sum + choose(size,t)*p^t*(1-p)^(size-t)
table = c(table, sum)
}
length(size)+1
length(size)
U=runif(n) # generate random numbers following uniform distribution
sum = 0
table = c()
for (t in 0:size){
sum = sum + choose(size,t)*p^t*(1-p)^(size-t)
table = c(table, sum)
}
# check where does U locate
X = c()
for (i in 1:n){
for (j in 1:(size+1)){
if (U[i] <= table[j]) {
X = c(X, j-1)
break
}
}
}
length(X)
X
binomial_inverse(100, 5, 0.2)
n = 100
size = 5
p = 0.2
binomial_inverse = function(n,size, p)
{
U=runif(n) # generate random numbers following uniform distribution
sum = 0
table = c()
for (t in 0:size){
sum = sum + choose(size,t)*p^t*(1-p)^(size-t)
table = c(table, sum)
}
# check where does U locate
X = c()
for (i in 1:n){
for (j in 1:(size+1)){
if (U[i] <= table[j]) {
X = c(X, j-1)
break
}
}
}
length(X)
return(X)
}
# 두 값의 차이를 계산하는 것이 좋을 거 같다.
# 3) Calculate the mean and variance for random numbers generated from parts (1) and (2), respectively, and compare them with the theoretical mean and variance.
mean(binomial_inverse(100, 5, 0.2))
var(binomial_inverse(100, 5, 0.2))
mean(binomial_transform(100,5,0.2))
var(binomial_transform(100,5,0.2))
# theoritical mean
size*p
# theoritical variance
size*p*(1-p)
binomial_inverse = function(n,size, p)
{
U=runif(n) # generate random numbers following uniform distribution
sum = 0
table = c()
for (t in 0:size){
sum = sum + choose(size,t)*p^t*(1-p)^(size-t)
table = c(table, sum)
}
# check where does U locate
X = c()
for (i in 1:n){
for (j in 1:(size+1)){
if (U[i] <= table[j]) {
X = c(X, j-1)
break
}
}
}
length(X)
return(X)
}
binomial_inverse(100, 5, 0.2)
# function for generating Beroulli(p)
Ber.R = function(n,p)
{
U = runif(n)
X = ifelse(U <= p,1,0)
return(X)
}
# rbinom(n, 1,...) 해서 사용할 수도 있을 듯.
# generate binomial random number
binomial_transform = function(n,size, p){
X = c()
for (i in 1:n){
x = sum(Ber.R(size,p))
X = c(X,x)
}
return(X)
}
binomial_transform(100,5,0.2)
# 두 값의 차이를 계산하는 것이 좋을 거 같다.
# 3) Calculate the mean and variance for random numbers generated from parts (1) and (2), respectively, and compare them with the theoretical mean and variance.
print(paste("inverse transformation mean: " , mean(binomial_inverse(100, 5, 0.2))))
print(paste("inverse transformation var: " , var(binomial_inverse(100, 5, 0.2))))
print(paste("transformation mean: " , mean(binomial_transform(100,5,0.2))))
print(paste("transformation var: " , var(binomial_transform(100,5,0.2))))
# theoritical mean
print(paste("theoreotical mean: " , size*p))
# theoritical variance
print(paste("theoreotical var: ", size*p*(1-p)))
# 두 값의 차이를 계산하는 것이 좋을 거 같다.
# 3) Calculate the mean and variance for random numbers generated from parts (1) and (2), respectively, and compare them with the theoretical mean and variance.
print(paste("inverse transformation mean: " , mean(binomial_inverse(100, 5, 0.2), "\n", "Compare with theoreotical mean: ", mean(binomial_inverse(100, 5, 0.2) - size*p))))
# 두 값의 차이를 계산하는 것이 좋을 거 같다.
# 3) Calculate the mean and variance for random numbers generated from parts (1) and (2), respectively, and compare them with the theoretical mean and variance.
print(paste("inverse transformation mean: " , mean(binomial_inverse(100, 5, 0.2), "\n", "Compare with theoreotical mean: ", mean(binomial_inverse(100, 5, 0.2) - size*p))))
# 두 값의 차이를 계산하는 것이 좋을 거 같다.
# 3) Calculate the mean and variance for random numbers generated from parts (1) and (2), respectively, and compare them with the theoretical mean and variance.
print(paste("inverse transformation mean: " , mean(binomial_inverse(100, 5, 0.2),"Compare with theoreotical mean: ", mean(binomial_inverse(100, 5, 0.2) - size*p))))
# 두 값의 차이를 계산하는 것이 좋을 거 같다.
# 3) Calculate the mean and variance for random numbers generated from parts (1) and (2), respectively, and compare them with the theoretical mean and variance.
print(paste("inverse transformation mean: " , mean(binomial_inverse(100, 5, 0.2),"Compare with theoreotical mean: ", mean(binomial_inverse(100, 5, 0.2) - as.integer(size*p))))
# 두 값의 차이를 계산하는 것이 좋을 거 같다.
# 3) Calculate the mean and variance for random numbers generated from parts (1) and (2), respectively, and compare them with the theoretical mean and variance.
print(paste("inverse transformation mean: " , mean(binomial_inverse(100, 5, 0.2),"Compare with theoreotical mean: ", mean(binomial_inverse(100, 5, 0.2) - as.integer(size*p))))
print(paste("transformation mean: " , mean(binomial_transform(100,5,0.2))))
# 두 값의 차이를 계산하는 것이 좋을 거 같다.
# 3) Calculate the mean and variance for random numbers generated from parts (1) and (2), respectively, and compare them with the theoretical mean and variance.
print(paste("inverse transformation mean: " , mean(binomial_inverse(100, 5, 0.2),"Compare with theoreotical mean: ", mean(binomial_inverse(100, 5, 0.2) - as.integer(size*p))))
# 두 값의 차이를 계산하는 것이 좋을 거 같다.
# 3) Calculate the mean and variance for random numbers generated from parts (1) and (2), respectively, and compare them with the theoretical mean and variance.
print(paste("inverse transformation mean: " , mean(binomial_inverse(100, 5, 0.2),"Compare with theoreotical mean: ", mean(binomial_inverse(100, 5, 0.2) - as.integer(size*p)))))
# 두 값의 차이를 계산하는 것이 좋을 거 같다.
# 3) Calculate the mean and variance for random numbers generated from parts (1) and (2), respectively, and compare them with the theoretical mean and variance.
print(paste("inverse transformation mean: " , mean(binomial_inverse(100, 5, 0.2),"Compare with theoreotical mean: ", mean(binomial_inverse(100, 5, 0.2) - as.integer(size*p)))))
# 두 값의 차이를 계산하는 것이 좋을 거 같다.
# 3) Calculate the mean and variance for random numbers generated from parts (1) and (2), respectively, and compare them with the theoretical mean and variance.
print(paste("inverse transformation mean: " , mean(binomial_inverse(100, 5, 0.2),"Compare with theoreotical mean: ", mean(binomial_inverse(100, 5, 0.2)) - size*p))))
# 두 값의 차이를 계산하는 것이 좋을 거 같다.
# 3) Calculate the mean and variance for random numbers generated from parts (1) and (2), respectively, and compare them with the theoretical mean and variance.
print(paste("inverse transformation mean: " , mean(binomial_inverse(100, 5, 0.2),"Compare with theoreotical mean: ", mean(binomial_inverse(100, 5, 0.2)) - size*p))))
# 두 값의 차이를 계산하는 것이 좋을 거 같다.
# 3) Calculate the mean and variance for random numbers generated from parts (1) and (2), respectively, and compare them with the theoretical mean and variance.
print(paste("inverse transformation mean: " , mean(binomial_inverse(100, 5, 0.2),"Compare with theoreotical mean: ", (mean(binomial_inverse(100, 5, 0.2)) - size*p)))))
# 두 값의 차이를 계산하는 것이 좋을 거 같다.
# 3) Calculate the mean and variance for random numbers generated from parts (1) and (2), respectively, and compare them with the theoretical mean and variance.
print(paste("inverse transformation mean: " , mean(binomial_inverse(100, 5, 0.2),"Compare with theoreotical mean: ", (mean(binomial_inverse(100, 5, 0.2)) - size*p))))
# 두 값의 차이를 계산하는 것이 좋을 거 같다.
# 3) Calculate the mean and variance for random numbers generated from parts (1) and (2), respectively, and compare them with the theoretical mean and variance.
print(paste("inverse transformation mean: " , mean(binomial_inverse(100, 5, 0.2)),"Compare with theoreotical mean: ", (mean(binomial_inverse(100, 5, 0.2)) - size*p)))
# 두 값의 차이를 계산하는 것이 좋을 거 같다.
# 3) Calculate the mean and variance for random numbers generated from parts (1) and (2), respectively, and compare them with the theoretical mean and variance.
print(paste("inverse transformation mean: " , mean(binomial_inverse(100, 5, 0.2)),"\nCompare with theoreotical mean: ", (mean(binomial_inverse(100, 5, 0.2)) - size*p)))
# 두 값의 차이를 계산하는 것이 좋을 거 같다.
# 3) Calculate the mean and variance for random numbers generated from parts (1) and (2), respectively, and compare them with the theoretical mean and variance.
print(paste("inverse transformation mean: " , mean(binomial_inverse(100, 5, 0.2)),"\nCompare with theoreotical mean: ", (mean(binomial_inverse(100, 5, 0.2)) - size*p)))
# 두 값의 차이를 계산하는 것이 좋을 거 같다.
# 3) Calculate the mean and variance for random numbers generated from parts (1) and (2), respectively, and compare them with the theoretical mean and variance.
mean = mean(binomial_inverse(100, 5, 0.2))
print(paste("inverse transformation mean: " , mean,"Compare with theoreotical mean: ", mean - size*p))
# 두 값의 차이를 계산하는 것이 좋을 거 같다.
# 3) Calculate the mean and variance for random numbers generated from parts (1) and (2), respectively, and compare them with the theoretical mean and variance.
X = binomial_inverse(100, 5, 0.2)
mean = mean(X)
var = var(X)
print(paste("inverse transformation mean: " , mean,"//Compare with theoreotical mean: ", mean - size*p))
print(paste("inverse transformation var: ", var, "//Compare with theoreotical var: ", var - size*p*(1-p)))
X2 = binomial_transform(100, 5, 0.2)
mean = mean(X2)
var = var(X2)
print(paste("transformation mean: " , mean,"//Compare with theoreotical mean: ", mean - size*p))
print(paste("transformation var: " , var, "//Compare with theoreotical var: ", var - size*p*(1-p)))
size*p*(1-p)
# 두 값의 차이를 계산하는 것이 좋을 거 같다.
# 3) Calculate the mean and variance for random numbers generated from parts (1) and (2), respectively, and compare them with the theoretical mean and variance.
X = binomial_inverse(100, 5, 0.2)
mean = mean(X)
var = var(X)
print(paste("inverse transformation mean: " , mean,"//Compare with theoreotical mean: ", mean - size*p))
print(paste("inverse transformation var: ", var, "//Compare with theoreotical var: ", var - size*p*(1-p)))
X2 = binomial_transform(100, 5, 0.2)
mean = mean(X2)
var = var(X2)
print(paste("transformation mean: " , mean,"//Compare with theoreotical mean: ", mean - size*p))
print(paste("transformation var: " , var, "//Compare with theoreotical var: ", var - size*p*(1-p)))
pois = function(n, lambda){
U=runif(n)
X = NULL
for (i in 1:n){
y = 0
p = exp(-lambda)
f = p
while(U[i] >= f){
p = (lambda/(y+1))*p
f = f + p
y = y + 1
}
X = c(X,y)
}
return(X)
}
pois(100,2)
# compute mean and variance
print(paste("mean: ", mean(pois(100, 2))))
print(paste("var: " , var(pois(100, 2))))
# 1) Generate 1,000 random numbers of X using the inverse transformation method and estimate E(X) and Var(X) using the 1,000 random numbers.
func = function(n){
U = runif(n)     #uniroot(function(x) (x^2) / 4 + x / 2 + 1 / 4 - rand_unf, lower = -1, upper = 1, tol = 0.0001)$root
X = 2*sqrt(U) - 1
return(X)
}
func(1000)
print(paste("mean: ", mean(func(1000))))
print(paste("var: " ,var(func(1000))))
# 2) Let Y = X^2. Estimate E(Y) and Var(Y) using the 1,000 random numbers obtained part(1).
X = func(1000)
Y = X^2
print(paste("mean: ", mean(Y)))
print(paste("var: " ,var(Y)))
X = func(1000)
print(paste("mean: ", mean(X)))
print(paste("var: " ,var(X)))
# 2) Let Y = X^2. Estimate E(Y) and Var(Y) using the 1,000 random numbers obtained part(1).
Y = X^2
print(paste("mean: ", mean(Y)))
print(paste("var: " ,var(Y)))
min_c = 3/2
# 2) Using the acceptance-rejection method and c obtaind in part (1), generate 100 random numbers from f(x), and then compute the mean and variance of the 100 random numbers.
n = 100
X = NULL
N = 0
trials = 0
while (N <= n){
Y = runif(1)
U = runif(1)
C = 4 * Y * (1-Y)
X = c(X,Y[U <= C])
N = length(X)
if (N > n) X = X[1:n]
trials = trials + 1
}
print(paste("mean: ",mean(X)))
print(paste("var: " ,var(X)))
trials / 100
rmvn.eigen = function(n, mu, Sigma)
{
# generate n random vectors from MVN(mu, Sigma)
# dimension is inferred from mu and Sigma
d = length(mu)
Z = matrix(rnorm(n*d), nrow = n, ncol = d)
L = t(chol(Sigma))
X = Z %*% L + mu
return(X)
}
# mean and covariance parameters
mu = c(0, 1, 2)
Sigma = matrix(c(1, -0.5, 0.5, -0.5, 1, -0.5, 0.5, -0.5, 1), nrow = 3, ncol = 3)
# generate the sample
X = rmvn.eigen(200, mu, Sigma)
colnames(X) <- c("Var1", "Var2", "Var3")
pairs(~Var1 + Var2 + Var3, data = X)
